// Objective-C API for talking to github.com/getlantern/flashlight/v7/ios Go package.
//   gobind -lang=objc github.com/getlantern/flashlight/v7/ios
//
// File is generated by gobind. Do not edit.

#ifndef __Ios_H__
#define __Ios_H__

@import Foundation;
#include "ref.h"
#include "Universe.objc.h"


@class IosCanceler;
@class IosConfigResult;
@class IosProCredentials;
@class IosUDPCallbacks;
@class IosUserConfig;
@protocol IosClientWriter;
@class IosClientWriter;
@protocol IosMemChecker;
@class IosMemChecker;
@protocol IosUDPConn;
@class IosUDPConn;
@protocol IosUDPDialer;
@class IosUDPDialer;
@protocol IosWriter;
@class IosWriter;

@protocol IosClientWriter <NSObject>
- (BOOL)close:(NSError* _Nullable* _Nullable)error;
/**
 * Reconfigure forces the ClientWriter to update its configuration
 */
- (void)reconfigure;
/**
 * Write writes the given bytes. As a side effect of writing, we periodically
record updated bandwidth quota information in the configured quota.txt file.
If user has exceeded bandwidth allowance, returns a positive integer
representing the bandwidth allowance.
 */
- (BOOL)write:(NSData* _Nullable)p0 ret0_:(long* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
@end

@protocol IosMemChecker <NSObject>
/**
 * BytesRemain returns the number of bytes of memory left before we hit the system limit
 */
- (long)bytesRemain;
@end

@protocol IosUDPConn <NSObject>
/**
 * Close closes the UDPConn
 */
- (void)close;
/**
 * ReceiveDatagram requests receipt of the next datagram from the UDPConn. Once the datagram is received,
it's sent to UDPCallbacks.OnReceive.
 */
- (void)receiveDatagram;
/**
 * RegisterCallbacks registers lifecycle callbacks for the connection. Clients of the UDPConn
must call this before trying to use WriteDatagram and ReceiveDatagram.
 */
- (void)registerCallbacks:(IosUDPCallbacks* _Nullable)cb;
/**
 * WriteDatagram writes one datagram to the UDPConn. Any resulting error from the right will
be reported to UDPCallbacks.OnError.
 */
- (void)writeDatagram:(NSData* _Nullable)p0;
@end

@protocol IosUDPDialer <NSObject>
- (id<IosUDPConn> _Nullable)dial:(NSString* _Nullable)host port:(long)port;
@end

@protocol IosWriter <NSObject>
- (BOOL)write:(NSData* _Nullable)p0;
@end

/**
 * Canceler providers a mechanism for canceling long running operations
 */
@interface IosCanceler : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * NewCanceler creates a Canceller
 */
- (nullable instancetype)init;
/**
 * Cancel cancels an operation
 */
- (void)cancel;
@end

/**
 * ConfigResult captures the result of calling Configure()
 */
@interface IosConfigResult : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * VPNNeedsReconfiguring indicates that something in the config changed and
that the VPN needs to be reconfigured.
 */
@property (nonatomic) BOOL vpnNeedsReconfiguring;
/**
 * IPSToExcludeFromVPN lists all IPS that should be excluded from the VPNS's
routes in a comma-delimited string
 */
@property (nonatomic) NSString* _Nonnull ipsToExcludeFromVPN;
@end

/**
 * ProCredentials are credentials that authenticate a pro account
 */
@interface IosProCredentials : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
@property (nonatomic) long userID;
@property (nonatomic) NSString* _Nonnull proToken;
@end

@interface IosUDPCallbacks : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * OnClose is called when the connection is closed.
 */
- (void)onClose;
/**
 * OnConn is called once a connection is successfully dialed
 */
- (void)onDialSucceeded;
- (void)onError:(NSError* _Nullable)err;
- (void)onReceive:(NSData* _Nullable)dgram;
- (void)onWritten;
@end

@interface IosUserConfig : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
// skipped field UserConfig.UserConfigData with unsupported type: github.com/getlantern/flashlight/v7/common.UserConfigData

@property (nonatomic) NSString* _Nonnull country;
@property (nonatomic) BOOL allowProbes;
- (NSString* _Nonnull)getAppName;
- (NSString* _Nonnull)getDeviceID;
// skipped method UserConfig.GetEnabledExperiments with unsupported parameter or return types

// skipped method UserConfig.GetInternalHeaders with unsupported parameter or return types

- (NSString* _Nonnull)getLanguage;
- (NSString* _Nonnull)getTimeZone:(NSError* _Nullable* _Nullable)error;
- (NSString* _Nonnull)getToken;
- (int64_t)getUserID;
@end

FOUNDATION_EXPORT id<IosClientWriter> _Nullable IosClient(id<IosWriter> _Nullable packetsOut, id<IosUDPDialer> _Nullable udpDialer, id<IosMemChecker> _Nullable memChecker, NSString* _Nullable configDir, long mtu, NSString* _Nullable capturedDNSHost, NSString* _Nullable realDNSHost, NSError* _Nullable* _Nullable error);

/**
 * Configure fetches updated configuration from the cloud and stores it in
configFolderPath. There are 5 files that must be initialized in
configFolderPath - global.yaml, global.yaml.etag, proxies.yaml,
proxies.yaml.etag and masquerade_cache. deviceID should be a string that
uniquely identifies the current device. hardcodedProxies allows manually specifying
a proxies.yaml configuration that overrides whatever we fetch from the cloud.
 */
FOUNDATION_EXPORT IosConfigResult* _Nullable IosConfigure(NSString* _Nullable configFolderPath, long userID, NSString* _Nullable proToken, NSString* _Nullable deviceID, BOOL refreshProxies, NSString* _Nullable hardcodedProxies, NSError* _Nullable* _Nullable error);

/**
 * ConfigureFileLogging configures logging to log to files at the given fullLogFilePath
and capture heap and goroutine profiles at the given profile path.
 */
FOUNDATION_EXPORT BOOL IosConfigureFileLogging(NSString* _Nullable fullLogFilePath, NSString* _Nullable profilePath, NSError* _Nullable* _Nullable error);

/**
 * IsActiveProDevice checks whether the given device is an active pro device
 */
FOUNDATION_EXPORT BOOL IosIsActiveProDevice(long userID, NSString* _Nullable proToken, NSString* _Nullable deviceID, BOOL* _Nullable ret0_, NSError* _Nullable* _Nullable error);

/**
 * LogDebug logs the given msg to the swift logger at debug level
 */
FOUNDATION_EXPORT void IosLogDebug(NSString* _Nullable msg);

/**
 * LogError logs the given msg to the swift logger at error level
 */
FOUNDATION_EXPORT void IosLogError(NSString* _Nullable msg);

/**
 * NewCanceler creates a Canceller
 */
FOUNDATION_EXPORT IosCanceler* _Nullable IosNewCanceler(void);

/**
 * RecoverProAccount attempts to recover an existing Pro account linked to this email address and device ID
 */
FOUNDATION_EXPORT IosProCredentials* _Nullable IosRecoverProAccount(NSString* _Nullable deviceID, NSString* _Nullable emailAddress, NSError* _Nullable* _Nullable error);

/**
 * RedeemResellerCode redeems the given reseller code, returning the payment_status and the plan
 */
FOUNDATION_EXPORT BOOL IosRedeemResellerCode(long userID, NSString* _Nullable proToken, NSString* _Nullable deviceID, NSString* _Nullable emailAddress, NSString* _Nullable resellerCode, NSString* _Nullable deviceName, NSString* _Nullable currency, NSError* _Nullable* _Nullable error);

/**
 * ReportIssue reports an issue via email.
 */
FOUNDATION_EXPORT BOOL IosReportIssue(BOOL isPro, long userID, NSString* _Nullable proToken, NSString* _Nullable deviceID, NSString* _Nullable appVersion, NSString* _Nullable deviceModel, NSString* _Nullable iosVersion, NSString* _Nullable emailAddress, NSString* _Nullable issue, NSString* _Nullable appLogsDir, NSString* _Nullable tunnelLogsDir, NSString* _Nullable proxiesYamlPath, NSError* _Nullable* _Nullable error);

/**
 * RequestDeviceLinkingCode requests a new device linking code to allow linking the current device to a pro account via an existing pro device.
 */
FOUNDATION_EXPORT NSString* _Nonnull IosRequestDeviceLinkingCode(NSString* _Nullable deviceID, NSString* _Nullable deviceName, NSError* _Nullable* _Nullable error);

/**
 * RequestRecoveryEmail requests an account recovery email for linking to an existing pro account
 */
FOUNDATION_EXPORT BOOL IosRequestRecoveryEmail(NSString* _Nullable deviceID, NSString* _Nullable deviceName, NSString* _Nullable emailAddress, NSError* _Nullable* _Nullable error);

FOUNDATION_EXPORT void IosSetProfilePath(NSString* _Nullable path);

/**
 * UserCreate creates a new user account on the pro server
 */
FOUNDATION_EXPORT IosProCredentials* _Nullable IosUserCreate(NSString* _Nullable deviceID, NSError* _Nullable* _Nullable error);

/**
 * ValidateDeviceLinkingCode validates a device linking code to allow linking the current device to a pro account via an existing pro device.
It will keep trying until it succeeds or the supplied Canceler is canceled. In the case of cancel, it will return nil credentials and a nil
error.
 */
FOUNDATION_EXPORT IosProCredentials* _Nullable IosValidateDeviceLinkingCode(IosCanceler* _Nullable c, NSString* _Nullable deviceID, NSString* _Nullable deviceName, NSString* _Nullable code, NSError* _Nullable* _Nullable error);

/**
 * ValidateRecoveryCode validates the given recovery code and finishes linking the device, returning the user_id and pro_token for the account.
 */
FOUNDATION_EXPORT IosProCredentials* _Nullable IosValidateRecoveryCode(NSString* _Nullable deviceID, NSString* _Nullable code, NSError* _Nullable* _Nullable error);

@class IosClientWriter;

@class IosMemChecker;

@class IosUDPConn;

@class IosUDPDialer;

@class IosWriter;

@interface IosClientWriter : NSObject <goSeqRefInterface, IosClientWriter> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (BOOL)close:(NSError* _Nullable* _Nullable)error;
/**
 * Reconfigure forces the ClientWriter to update its configuration
 */
- (void)reconfigure;
/**
 * Write writes the given bytes. As a side effect of writing, we periodically
record updated bandwidth quota information in the configured quota.txt file.
If user has exceeded bandwidth allowance, returns a positive integer
representing the bandwidth allowance.
 */
- (BOOL)write:(NSData* _Nullable)p0 ret0_:(long* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
@end

/**
 * MemChecker checks the system's memory level
 */
@interface IosMemChecker : NSObject <goSeqRefInterface, IosMemChecker> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * BytesRemain returns the number of bytes of memory left before we hit the system limit
 */
- (long)bytesRemain;
@end

/**
 * UDPConn is a UDP connection that bypasses the VPN. It is backed by an NWConnection on the
Swift side.

See https://developer.apple.com/documentation/network/nwconnection.
 */
@interface IosUDPConn : NSObject <goSeqRefInterface, IosUDPConn> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * Close closes the UDPConn
 */
- (void)close;
/**
 * ReceiveDatagram requests receipt of the next datagram from the UDPConn. Once the datagram is received,
it's sent to UDPCallbacks.OnReceive.
 */
- (void)receiveDatagram;
/**
 * RegisterCallbacks registers lifecycle callbacks for the connection. Clients of the UDPConn
must call this before trying to use WriteDatagram and ReceiveDatagram.
 */
- (void)registerCallbacks:(IosUDPCallbacks* _Nullable)cb;
/**
 * WriteDatagram writes one datagram to the UDPConn. Any resulting error from the right will
be reported to UDPCallbacks.OnError.
 */
- (void)writeDatagram:(NSData* _Nullable)p0;
@end

/**
 * UDPDialer provides a mechanism for dialing outbound UDP connections that bypass the VPN.
The returned UDPConn is not immediately ready for use, only once the UDPCallbacks receive
OnDialSuccess is the UDPConn ready for use.
 */
@interface IosUDPDialer : NSObject <goSeqRefInterface, IosUDPDialer> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (id<IosUDPConn> _Nullable)dial:(NSString* _Nullable)host port:(long)port;
@end

@interface IosWriter : NSObject <goSeqRefInterface, IosWriter> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (BOOL)write:(NSData* _Nullable)p0;
@end

#endif
