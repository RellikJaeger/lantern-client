package internalsdk

import (
	"database/sql"

	"github.com/getlantern/pathdb/minisql"
)

// The below interfaces are copied from github.com/getlantern/pathdb/minisql so that we can generate
// gomoboile bindings in the same package as internalsdk.

type Rows interface {
	Close() error
	Next() bool
	Scan(dest ValueArray) error
}

type rowsAdapter struct {
	Rows
}

func (a *rowsAdapter) Scan(dest ...interface{}) error {
	va := make(valueArray, len(dest))
	err := a.Rows.Scan(va)
	if err != nil {
		return err
	}
	for i := 0; i < va.Len(); i++ {
		dest[i] = va.Get(i).asInterface()
	}
	return nil
}

// Result is a duplicate of sql.Result to allow binding with gomobile
type Result interface {
	// LastInsertId returns the integer generated by the database
	// in response to a command. Typically this will be from an
	// "auto increment" column when inserting a new row. Not all
	// databases support this feature, and the syntax of such
	// statements varies.
	LastInsertId() (int64, error)

	// RowsAffected returns the number of rows affected by an
	// update, insert, or delete. Not every database or database
	// driver may support this.
	RowsAffected() (int64, error)
}

type Queryable interface {
	Exec(query string, args ValueArray) (Result, error)
	Query(query string, args ValueArray) (Rows, error)
}

type DB interface {
	Close() error
	Queryable
	Begin() (Tx, error)
}

type dbAdapter struct {
	DB
}

func (a *dbAdapter) Exec(query string, args ...interface{}) (sql.Result, error) {
	va := newValueArray(args)
	return a.DB.Exec(query, va)
}

func (a *dbAdapter) Query(query string, args ...interface{}) (minisql.Rows, error) {
	va := newValueArray(args)
	rows, err := a.DB.Query(query, va)
	if err != nil {
		return nil, err
	}
	return &rowsAdapter{rows}, nil
}

func (a *dbAdapter) Begin() (minisql.Tx, error) {
	tx, err := a.DB.Begin()
	if err != nil {
		return nil, err
	}
	return &txAdapter{tx}, nil
}

type Tx interface {
	Queryable
	Commit() error
	Rollback() error
}

type txAdapter struct {
	Tx
}

func (a *txAdapter) Exec(query string, args ...interface{}) (sql.Result, error) {
	va := newValueArray(args)
	return a.Tx.Exec(query, va)
}

func (a *txAdapter) Query(query string, args ...interface{}) (minisql.Rows, error) {
	va := newValueArray(args)
	rows, err := a.Tx.Query(query, va)
	if err != nil {
		return nil, err
	}
	return &rowsAdapter{rows}, nil
}
